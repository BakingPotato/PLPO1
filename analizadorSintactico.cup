import java_cup.runtime.*;
import java.util.LinkedList;


action code{:
     public void reconocido(String r){
            System.out.println("Se ha reconocido " + "\"" + r + "\"");
        }
 :}

parser code{:   // hay que averiguar que hace

:}


/* Terminales */
terminal program, begin, end, const_, var, procedure, function, unit;
terminal if_, then, else_, while_, do_, repeat, until, to, downto ,bucle_for;
terminal integer, real, div, mod, or, and, not, lt, gt, let, bet;
terminal igual, op_mas, op_men, op_mul, coma, punto, dos_puntos, punto_coma, dos_p_igual, ab_parentesis, cr_parentesis;
terminal String identifier, string_const;
terminal Integer numeric_integer_const;
terminal numeric_real_const;

/* No terminales */
non terminal PRG, BLQ, DCLLIST, SENTLIST;
non terminal DCL, DEFCTE, CTELIST, SIMPVALUE, DEFVAR, DEFVARLIST, VARLIST, DEFPROC, DEFFUN, FORMAL_PARAMLIST, FORMAL_PARAM, TBAS;
non terminal SENT, ASIG, ID, EXP, OP, OPARIT, FACTOR, SUBPPARAMLIST, EXPLIST, PROC_CALL;
non terminal EXPCOND, OPLOG, FACTORCOND, OPCOMP, INC;

/* Precedences */
precedence left lt, gt, let, bet;
precedence left op_mas, op_men, or;
precedence left op_mul, div, mod, and;
precedence left not;

/* Grammar */
start with PRG;

PRG ::= program identifier punto_coma BLQ punto  {: reconocido("PRG"); :}
      | unit identifier punto_coma DCLLIST punto {: reconocido("PRG"); :} ;           // Distinguir entre librerias y programas (opcional)

BLQ ::= DCLLIST begin SENTLIST end {: reconocido("BQL"); :} ;

DCLLIST ::= /* lambda */ | DCLLIST DCL;

SENTLIST ::= SENT  {: reconocido("SENTLIST"); :}
           | SENTLIST SENT {: reconocido("SENTLIST"); :} ;

// Zona de declaraciones
DCL ::= DEFCTE  {: reconocido("DCL"); :}
      | DEFVAR  {: reconocido("DCL"); :}
      | DEFPROC {: reconocido("DCL"); :}
      | DEFFUN  {: reconocido("DCL"); :}  ;

DEFCTE ::= const_ CTELIST {: reconocido("DEFCTE"); :} ;

CTELIST ::= identifier igual SIMPVALUE punto_coma {: reconocido("CTELIST"); :}
          | CTELIST identifier igual SIMPVALUE punto_coma {: reconocido("CTELIST"); :} ;

SIMPVALUE ::= numeric_integer_const:i1
                {: RESULT = n1; :}
            | numeric_real_const:r1
                {: RESULT = r1; :}
            | string_const:s1
                {: RESULT = s1; :} ;

DEFVAR ::= var DEFVARLIST punto_coma {: reconocido("DEFVAR"); :} ;

DEFVARLIST ::= VARLIST dos_puntos TBAS {: reconocido("DEFVARLIST"); :}
             | DEFVARLIST punto_coma VARLIST dos_puntos TBAS {: reconocido("DEFVARLIST"); :} ;

VARLIST ::= identifier | identifier coma VARLIST {: reconocido("VARLIST"); :} ;

DEFPROC ::=  procedure identifier FORMAL_PARAMLIST punto_coma BLQ punto_coma {: reconocido("DEFPROC"); :} ;

DEFFUN ::=  function identifier FORMAL_PARAMLIST dos_puntos TBAS punto_coma BLQ punto_coma  {: reconocido("DEFFUN"); :};

FORMAL_PARAMLIST ::= ab_parentesis FORMAL_PARAM cr_parentesis {: reconocido("FORMAL_PARAMLIST"); :} ;

FORMAL_PARAM ::= VARLIST dos_puntos TBAS {: reconocido("FORMAL_PARAM"); :}
               | VARLIST dos_puntos TBAS punto_coma FORMAL_PARAM {: reconocido("FORMAL_PARAM"); :}
               | /* lambda */ {: reconocido("FORMAL_PARAM"); :};

TBAS ::= integer  {: reconocido("TBAS"); :}
       | real     {: reconocido("TBAS"); :} ;

// Zona de sentencias
SENT ::= ASIG punto_coma  {: reconocido("SENT"); :}
       | PROC_CALL punto_coma {: reconocido("SENT"); :}
       | if_ EXPCOND then BLQ else_ BLQ {: reconocido("SENT"); :}                            // parte opcional
       | while_ EXPCOND do_ BLQ  {: reconocido("SENT"); :}                                   // parte opcional
       | repeat BLQ until EXPCOND punto_coma  {: reconocido("SENT"); :}                      // parte opcional
       | bucle_for identifier dos_p_igual EXP INC EXP do_ BLQ  {: reconocido("SENT"); :} ;   // parte opcional

INC ::= to {: reconocido("INC"); :}
      | downto {: reconocido("INC"); :};                            // parte opcional

ASIG ::= ID dos_p_igual EXP {: reconocido("ASIG"); :} ;

ID ::= identifier:i1 {: RESULT = i1; :};

EXP ::= EXP OP EXP {: reconocido("EXP"); :}
      | FACTOR {: reconocido("EXP"); :} ;

OP ::= OPARIT {: reconocido("OP"); :};

OPARIT ::= op_mas  {: reconocido("OPARIT"); :}
         | op_men  {: reconocido("OPARIT"); :}
         | op_mul  {: reconocido("OPARIT"); :}
         | div     {: reconocido("OPARIT"); :}
         | mod     {: reconocido("OPARIT"); :};

FACTOR ::= SIMPVALUE {: reconocido("FACTOR"); :}
         | ab_parentesis EXP cr_parentesis {: reconocido("FACTOR"); :}
         | identifier SUBPPARAMLIST {: reconocido("FACTOR"); :} ;

SUBPPARAMLIST ::= /* lambda */ {: reconocido("SUBPPARAMLIST"); :}
                | ab_parentesis EXPLIST cr_parentesis {: reconocido("SUBPPARAMLIST"); :} ;

EXPLIST ::= EXP {: reconocido("EXPLIST"); :}
          | EXP coma EXPLIST {: reconocido("EXPLIST"); :};

PROC_CALL ::= identifier SUBPPARAMLIST {: reconocido("PROC_CALL"); :};

// Comprobacion de expresiones condicionales (opcional)
EXPCOND ::= EXPCOND OPLOG EXPCOND {: reconocido("EXPCOND"); :}
          | FACTORCOND {: reconocido("EXPCOND"); :} ;

OPLOG ::= or  {: reconocido("OPLOG"); :}
         | and {: reconocido("OPLOG"); :} ;

FACTORCOND ::= EXP OPCOMP EXP {: reconocido("FACTORCOND"); :}
             | ab_parentesis EXP cr_parentesis {: reconocido("FACTORCOND"); :}
             | not FACTORCOND {: reconocido("FACTORCOND"); :} ;

OPCOMP ::= lt  {: reconocido("OPCOMP"); :}
         | gt  {: reconocido("OPCOMP"); :}
         | let {: reconocido("OPCOMP"); :}
         | bet {: reconocido("OPCOMP"); :}
         | igual {: reconocido("OPCOMP"); :};
