import java_cup.runtime.*;
import java.util.LinkedList;

parser code {: //Tratamiento de errores
    public void syntax_error (Symbol s){
	    System.err.println("Error de sintaxis (lexema <" + s.value.toString() + ">) en la linea " + s.left + " y en la columna " + s.right);
	    System.err.println("Error recuperado");
    }

    public void unrecovered_syntax_error(Symbol s){
	    System.err.println("Error de sintaxis grave");
    }
:};


/* Terminales */
terminal program, begin, end, const_, var, procedure, function, unit;
terminal if_, then, else_, while_, do_, repeat, until, to, downto ,bucle_for;
terminal integer, real, div, mod, or, and, not, lt, gt, let, bet;
terminal igual, op_mas, op_men, op_mul, coma, punto, dos_puntos, punto_coma, dos_p_igual, ab_parentesis, cr_parentesis;
terminal String identifier, string_const;
terminal Integer numeric_integer_const;
terminal numeric_real_const;

/* No terminales */
non terminal PRG, BLQ, DCLLIST, SENTLIST;
non terminal DCL, DEFCTE, SIMPVALUE, DEFVAR, DEFVARLIST;
non terminal SENT, ASIG, ID, EXP, OP, OPARIT, FACTOR, SUBPPARAMLIST, EXPLIST, PROC_CALL;
non terminal EXPCOND, OPLOG, FACTORCOND, OPCOMP, INC;
non terminal DefineList DEFCTE, CTELIST;
non terminal Funcion DEFFUN, DEFPROC, FORMAL_PARAMLIST, FORMAL_PARAM, VARLIST;
non terminal Simbolo TBAS;

/* Precedences */
precedence left lt, gt, let, bet;
precedence left op_mas, op_men, or;
precedence left op_mul, div, mod, and;
precedence left not;

/* Grammar */
start with PRG;

PRG ::= program identifier punto_coma BLQ:b punto  {:
                    RESULT = b;
                :}
      | unit identifier:id punto_coma DCLLIST:d punto {:
                StringBuilder s = new StringBuilder("// Librer√≠a: ").append(id).append("\n").append(d);

                :} ;           // Distinguir entre librerias y programas (opcional)

BLQ ::= DCLLIST:d begin SENTLIST:s end {:
                RESULT = d.append("\n\t{").append(s).append("}");
            :} ;

DCLLIST ::= /* lambda */ {:
                RESULT = new StringBuilder();
            :} | DCLLIST:dl DCL:d {:
                RESULT = dl.append(d);
                :};

SENTLIST ::= SENT:s  {:
                RESULT = s.valor;
                :}
           | SENTLIST:sl SENT:s {:
                RESULT = sl.append(sl).append(" ").append(s); :} ;

// Zona de declaraciones
DCL ::= DEFCTE:d  {: RESULT = d.print(); :}
      | DEFVAR:d  {: RESULT = d.print(); :}
      | DEFPROC:d {: RESULT = d; :}
      | DEFFUN:d  {: RESULT = d; :} ;

DEFCTE ::= const_ CTELIST:cl {: RESULT = cl; :} ;

CTELIST ::= identifier:i igual SIMPVALUE:sv punto_coma
            {:  DefineList dl = new DefineList();
                Define d = new Define();
                d.id = i;
                d.sim = sv;
                dl.defines.add(d);
                RESULT = dl; :}
        | CTELIST:cl identifier igual SIMPVALUE:sv punto_coma
            {: DefineList dl = cl;
               Define d = new Define();
               d.id = i;
               d.sim = sv;
               dl.defines.add(d);
               RESULT = dl; :} ;

SIMPVALUE ::= numeric_integer_const:i1
                {:  Simbolo s = new Simbolo();
                    s.tipo = TipoSim.T_INTEGER;
                    s.valor = new StringBuilder(i1);
                    RESULT = s; :}
            | numeric_real_const:r1
                {:  Simbolo s = new Simbolo();
                    s.tipo = TipoSim.T_FLOAT;
                    s.valor = new StringBuilder(r1);
                    RESULT = s; :}
            | string_const:s1
                {:  Simbolo s = new Simbolo();
                    s.tipo = TipoSim.T_STRING;
                    s.valor = new StringBuilder(s1);
                    RESULT = s; :} ;

DEFVAR ::= var DEFVARLIST:d punto_coma {: // estas deben ir en la funcion void main (void)
                                        Function f = d;
                                        f.type = "void";
                                        f.name = "main";
                                        RESULT = f;
                                        :} ;

DEFVARLIST ::= VARLIST:v dos_puntos TBAS:t {:
                    /*Funcion f = v;
                    f.tipo = t;
                    RESULT = f;*/
                    VarList vl = v;
                    v.tipo = t;
                    Function f = new Function();
                    f.varList.add(vl);
                    RESULT = f;
                    :}
             | DEFVARLIST:dvl punto_coma VARLIST:vl dos_puntos TBAS:t {:
                    Varlist v = vl;
                    v.tipo = t;
                    Function f = dvl;
                    f.varList.add(v);
                    RESULT = f;
                    :} ;

VARLIST ::= identifier:i
            {:  /*Funcion f = new Funcion(); // primero vamos metiendo parametros a la funcion
                f.paramList.add(new Variable().id.append(i));
                RESULT = f;*/
                VarList vl = new Varlist();
                vl.vars.add(i);
                RESULT = vl;
            :}
          | identifier:i coma VARLIST:vl
            {:  /*Funcion f = vl;
                f.paramList.add(new Variable().id.append(i));
                RESULT = f;*/
                VarList v = vl;
                v.vars.add(i);
                RESULT = v;
             :} ;

DEFPROC ::=  procedure identifier:i FORMAL_PARAMLIST:fpl punto_coma BLQ:b punto_coma
                {:  /*Funcion f = fpl; // Nos quedamos con la lista de parametros
                    f.name = i;
                    f.tipo = "void";
                    // bloque de sentencias
                    RESULT = f;*/
                    StringBuilder s = new StringBuilder("void ").append(i).append(fpl).append(";");
                    s.append(/*AQUI VA LO QUE SALGA DE BLQ*/).append(";");
                    RESULT = s;
                    :} ;

DEFFUN ::=  function identifier:i FORMAL_PARAMLIST:fpl dos_puntos TBAS:t punto_coma BLQ:b punto_coma
                {:  /*Funcion f = fpl;
                    f.name = i;
                    f.tipo = t.valor; // cogemos el valor que devuelve la funcion
                    // bloque de sentencias
                    RESULT = f;*/
                    StringBuilder s = new StringBuilder(t).append(" ").append(i).append(fpl).append(";");
                    s.append(/*AQUI VA LO QUE SALGA DE BLQ*/).append(";");
                    RESULT = s;
                    :};

FORMAL_PARAMLIST ::= ab_parentesis FORMAL_PARAM:fp cr_parentesis {:
                            StringBuilder r = new StringBuilder("( ");
                            r.append(fp.print()).append(")");
                            RESULT = r;
                            :} ;

FORMAL_PARAM ::= VARLIST:vl dos_puntos TBAS:t
                {:  /*Funcion f = vl;
                    for (Variable v : f.paramList) {
                        v.sim = t; // Actualizamos el tipo de los parametros
                    }
                    RESULT = f;*/
                    VarList v = vl;
                    v.type = t;
                    RESULT = v;
                 :}
               | VARLIST:vl dos_puntos TBAS:t punto_coma FORMAL_PARAM:fp
                {: /*Funcion f = vl;
                   for (Variable v : f.paramList) {
                       v.sim = t; // Actualizamos el tipo de los parametros
                   }
                   f.paramList.addAll(fp.paramList); // Anadimos los demas parametros de otros tipos
                   RESULT = f; */
                   VarList v = vl;
                   v.type = t;
                   Function f = fp;
                   f.varLists.add(v);
                   RESULT = f;
                   :}
               | /* lambda */ ;

TBAS ::= integer  {: Simbolo s = new Simbolo();
                     s.tipo = TipoSim.T_STRING;
                     s.valor = new StringBuilder("int");
                     RESULT = s; :}
       | real     {: Simbolo s = new Simbolo();
                     s.tipo = TipoSim.T_STRING;
                     s.valor = new StringBuilder("float");
                     RESULT = s; :} ;

// Zona de sentencias
SENT ::= ASIG:a punto_coma  {:
        Sentencia e = new Sentencia();
        e.valor.append(a.valor+";");
        RESULT = e;
    :}
    | PROC_CALL:pc punto_coma {:
        Sentencia e = new Sentencia();
        e.valor.append(pc.valor+";");
        RESULT = e;
    :}
    | if_ EXPCOND:ec then BLQ:blq1 else_ BLQ:blq2 {:
        Sentencia e = new Sentencia();
        e.valor.append("if("+ec.valor+")"+blq1.valor+"else"+blq2.valor);
        RESULT = e;
     :}
     | while_ EXPCOND:ec do_ BLQ:blq  {:
        Sentencia e = new Sentencia();
        e.valor.append("while("+ec.valor+")" +blq.valor);
        RESULT = e;
     :}
     | repeat BLQ:blq until EXPCOND:ec punto_coma  {:
        Sentencia e = new Sentencia();
        e.valor.append("do"+blq.valor+"until("+ec.valor+")");
        RESULT = e;
     :}
     | bucle_for identifier:id dos_p_igual EXP:exp1 INC:inc EXP:exp2 do_ BLQ:blq  {:
        Sentencia e = new Sentencia();
        e.valor.append("for("+id.valor+"="+exp1.valor+"; "+exp1.valor+inc.valor+exp2.valor+"; "+id.valor+"="+id.valor+inc.signo+")"+blq.valor);
        RESULT = e;
     :};

INC ::= to {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("<");
        s.signo = new StringBuilder("+1");
        RESULT = s;
    :}
     | downto {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder(">");
        s.signo = new StringBuilder("-1");
        RESULT = s;
    :};

ASIG ::= ID:id dos_p_igual EXP:exp {:
        Sentencia e = new Sentencia();

        e.valor.append(id.valor+" = "+exp.valor);
        RESULT = e;
    :};

ID ::= identifier:id {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder(id);
        RESULT = s;
    :};

EXP ::= EXP:exp1 OP:op EXP:exp2 {:
        Sentencia e = new Sentencia();

        e.valor.append(exp1.valor+" "+op.valor+" "+exp2.valor);
        RESULT = e;
    :}
    | FACTOR:fact {:
        RESULT = fact;
    :} ;


OP ::= OPARIT:o {:
        RESULT = o;
    :};

OPARIT ::= op_mas{:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("+");
        RESULT = s;
    :}
    | op_men{:
       Simbolo s = new Simbolo();
       s.valor = new StringBuilder("-")
       ;RESULT = s;
    :}
    | op_mul {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("*");
        RESULT = s;
    :}
    | div {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("/");
        RESULT = s;
    :}
     | mod {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("%");
        RESULT = s; :} ;

FACTOR ::= SIMPVALUE:sv {:
        RESULT = sv;
        :}
        | ab_parentesis EXP:exp cr_parentesis {:
            Sentencia e = new Sentencia();
            e.valor = new StringBuilder("("+exp.valor+")");
            RESULT = s;
        :}
         | identifier:id SUBPPARAMLIST:spl {:
            Sentencia e = new Sentencia();
            e.valor.append(id + " " + spl.valor);
            RESULT = e;
      :} ;

SUBPPARAMLIST ::= ab_parentesis EXPLIST:el cr_parentesis{:
                    Sentencia e = new Sentencia();
                    e.valor.append(" (" +el.valor+" ) ");
                    RESULT = e;
                :}
                | /*lambda*/ {:
                    RESULT = new Simbolo();
                     :} ;

EXPLIST ::= EXP:exp {:
        RESULT = exp;
    :}
     | EXP:exp coma EXPLIST:expl {:
        Sentencia e = new Sentencia();

        e.valor.append(exp.valor+", "+expl.valor);
        RESULT = e;
     :};

PROC_CALL ::= identifier:id SUBPPARAMLIST:spl {:
        Simbolo p = new Simbolo();

        p.valor.append(id.valor + " " + spl.valor);
        RESULT = p;
    :};

// Comprobacion de Sentenciaes condicionales (opcional)
EXPCOND ::= EXPCOND:exp1 OPLOG:op EXPCOND:exp2 {:
        Sentencia e = new Sentencia();

        e.valor.append(exp1.valor);
        e.valor.append(op.valor);
        e.valor.append(exp2.valor);
        RESULT = e;
    :}
    | FACTORCOND:fc {:
        RESULT = fc;
    :} ;

OPLOG ::= or  {:    Simbolo s = new Simbolo();
                    s.valor = new StringBuilder("||");
                    RESULT = s; :}
        | and {:    Simbolo s = new Simbolo();
                    s.valor = new StringBuilder("&&");
                    RESULT = s; :} ;

FACTORCOND ::= EXP:e1 OPCOMP:op EXP:e2 {:
        RESULT = new Simbolo(e1.valor + op.valor + e2.valor);
    :}
    | ab_parentesis EXP:exp cr_parentesis {:
        Simbolo s = new Simbolo();
        s.valor.append("(" + exp.valor + ")");
        RESULT = s;
    :}
    | not FACTORCOND:fc {:
        Simbolo s = new Simbolo();
        s.valor.append("!" + fc.valor);
        RESULT = s;
     :};

OPCOMP ::= lt  {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("<");
        RESULT = s;
    :}
    | gt  {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder(">");
        RESULT = s;
    :}
    | let {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("<=");
        RESULT = s;
    :}
    | bet {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder(">=");
        RESULT = s;
    :}
    | igual {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("==");
        RESULT = s;
    :};
