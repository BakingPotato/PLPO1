import java_cup.runtime.*;
import java.util.LinkedList;

parser code {: //Tratamiento de errores
    public void syntax_error (Symbol s){
	    System.err.println("Error de sintaxis (lexema <" + s.value.toString() + ">) en la linea " + s.left + " y en la columna " + s.right);
	    System.err.println("Error recuperado");
    }

    public void unrecovered_syntax_error(Symbol s){
	    System.err.println("Error de sintaxis grave");
    }
:};


/* Terminales */
terminal program, begin, end, const_, var, procedure, function, unit;
terminal if_, then, else_, while_, do_, repeat, until, to, downto ,bucle_for;
terminal integer, real, div, mod, or, and, not, lt, gt, let, bet;
terminal igual, op_mas, op_men, op_mul, coma, punto, dos_puntos, punto_coma, dos_p_igual, ab_parentesis, cr_parentesis;
terminal StringBuilder identifier, string_const, numeric_integer_const, numeric_real_const;

/* No terminales */
non terminal Incremento INC;
non terminal VarList VARLIST;
non terminal Bloque PRG, BLQ, DCLLIST, SENTLIST;
non terminal Function DCL, DEFCTE, CTELIST, DEFPROC, DEFFUN, DEFVAR, DEFVARLIST, FORMAL_PARAM, FORMAL_PARAMLIST;
non terminal Simbolo SIMPVALUE, TBAS, OP, OPARIT, ID, OPLOG;

non terminal Sentencia SENT, ASIG, SUBPPARAMLIST, EXPCOND, EXP, EXPLIST, PROC_CALL, FACTOR, FACTORCOND;
non terminal StringBuilder OPCOMP;

/* Precedences */
precedence left lt, gt, let, bet;
precedence left op_mas, op_men, or;
precedence left op_mul, div, mod, and;
precedence left not;

/* Grammar */
start with PRG;

PRG ::= program identifier punto_coma BLQ:b punto  {:
                    RESULT = b;
                :}
      | unit identifier:id punto_coma DCLLIST:d punto {:
                StringBuilder s = new StringBuilder("// Librería: ").append(id).append("\n").append(d);
                :} ;           // Distinguir entre librerias y programas (opcional)

BLQ ::= DCLLIST:d begin SENTLIST:s end {:
                /*RESULT = d.append("\n\t{").append(s).append("}");*/
                s.dclList = d.dclList;
                RESULT = s;
            :} ;

DCLLIST ::= /* lambda */ {:
                RESULT = new Bloque();
            :} | DCLLIST:dl DCL:d {:
                dl.dclList.add(d);
                :};

SENTLIST ::= SENT:s  {:
                /*RESULT = s.valor;*/
                Bloque b = new Bloque();
                b.sentList.add(s);
                RESULT = b;
                :}
           | SENTLIST:sl SENT:s {:
                /*RESULT = sl.append(sl).append(" ").append(s);*/
                sl.sentList.add(s);
                RESULT = sl;
            :} ;

// Zona de declaraciones
DCL ::= DEFCTE:d  {: RESULT = d; :}
      | DEFVAR:d  {: RESULT = d; :}
      | DEFPROC:d {: RESULT = d; :}
      | DEFFUN:d  {: RESULT = d; :} ;

DEFCTE ::= const_ CTELIST:cl {: RESULT = cl; :} ;

CTELIST ::= identifier:id igual SIMPVALUE:sv punto_coma
            {:  /*DefineList dl = new DefineList();
                Define d = new Define();
                d.id = i;
                d.sim = sv;
                dl.defines.add(d);
                RESULT = dl;*/
                VarList v = new VarList();
                v.vars.add(id + " = " + sv.valor + ";");
                Function f = new Function(true);
                f.varLists.add(v); // varLists puede tener varias varList, en este caso particular solo tendrá una (con varias variables)
                RESULT = f;
            :}
        | CTELIST:cl identifier:id igual SIMPVALUE:sv punto_coma
            {: /*DefineList dl = cl;
               Define d = new Define();
               d.id = i;
               d.sim = sv;
               dl.defines.add(d);
               RESULT = dl; */
                cl.varLists.peek().add(id + " = " + sv.valor + ";");
                RESULT = cl;
           :} ;

SIMPVALUE ::= numeric_integer_const:i1
                {:  Simbolo s = new Simbolo();
                    s.tipo = Simbolo.TipoSim.T_INTEGER;
                    s.valor = new StringBuilder(i1);
                    RESULT = s; :}
            | numeric_real_const:r1
                {:  Simbolo s = new Simbolo();
                    s.tipo = Simbolo.TipoSim.T_FLOAT;
                    s.valor = new StringBuilder(r1);
                    RESULT = s; :}
            | string_const:s1
                {:  Simbolo s = new Simbolo();
                    s.tipo = Simbolo.TipoSim.T_STRING;
                    s.valor = new StringBuilder(s1);
                    RESULT = s; :} ;

DEFVAR ::= var DEFVARLIST:d punto_coma {: // estas deben ir en la funcion void main (void)
                                        /*Function f = d;
                                        f.type = "void";
                                        f.name = "main";
                                        RESULT = f;*/
                                        RESULT = d;
                                        :} ;

DEFVARLIST ::= VARLIST:v dos_puntos TBAS:t {:
                    /*Funcion f = v;
                    f.tipo = t;
                    RESULT = f;*/
                    v.tipo = t;
                    Function f = new Function();
                    f.varLists.add(v);
                    RESULT = f;
                    :}
             | DEFVARLIST:dvl punto_coma VARLIST:vl dos_puntos TBAS:t {:
                    vl.tipo = t;
                    dvl.varLists.add(vl);
                    RESULT = dvl;
                    :} ;

VARLIST ::= identifier:i
            {:  /*Funcion f = new Funcion(); // primero vamos metiendo parametros a la funcion
                f.paramList.add(new Variable().id.append(i));
                RESULT = f;*/
                VarList vl = new VarList();
                vl.vars.push(i);
                RESULT = vl;
            :}
          | identifier:i coma VARLIST:vl
            {:  /*Funcion f = vl;
                f.paramList.add(new Variable().id.append(i));
                RESULT = f;*/
                VarList v = vl;
                v.vars.push(i);
                RESULT = v;
             :} ;

DEFPROC ::=  procedure identifier:i FORMAL_PARAMLIST:fpl punto_coma BLQ:blq punto_coma
                {:  /*Funcion f = fpl; // Nos quedamos con la lista de parametros
                    f.name = i;
                    f.tipo = "void";
                    // bloque de sentencias
                    RESULT = f;*/
                    /*StringBuilder s = new StringBuilder("void ").append(i).append(fpl).append(";");
                    s.append(blq).append(";");
                    RESULT = s;*/
                    fpl.type = "void";
                    fpl.name = i;
                    fpl.bloque = blq;
                    RESULT = fpl;
                    :} ;

DEFFUN ::=  function identifier:i FORMAL_PARAMLIST:fpl dos_puntos TBAS:t punto_coma BLQ:blq punto_coma
                {:  /*Funcion f = fpl;
                    f.name = i;
                    f.tipo = t.valor; // cogemos el valor que devuelve la funcion
                    // bloque de sentencias
                    RESULT = f;*/
                    /*StringBuilder s = new StringBuilder(t.valor).append(" ").append(i).append(fpl).append(";");
                    s.append(blq).append(";");
                    RESULT = s;*/
                    blq.id = i;
                    fpl.type = t;
                    fpl.name = i;
                    fpl.bloque = blq;
                    RESULT = fpl;
                    :};

FORMAL_PARAMLIST ::= ab_parentesis FORMAL_PARAM:fp cr_parentesis {:
                        RESULT = fp;
                    :}
                    | /* lambda */ {:
                        RESULT = new Function();
                    :} ;

FORMAL_PARAM ::= VARLIST:vl dos_puntos TBAS:t
                {:  /*Funcion f = vl;
                    for (Variable v : f.paramList) {
                        v.sim = t; // Actualizamos el tipo de los parametros
                    }
                    RESULT = f;*/
                    vl.tipo = t;
                    Function f = new Function();
                    f.varLists.push(vl);
                    RESULT = f;
                 :}
               | VARLIST:vl dos_puntos TBAS:t punto_coma FORMAL_PARAM:fp
                {: /*Funcion f = vl;
                   for (Variable v : f.paramList) {
                       v.sim = t; // Actualizamos el tipo de los parametros
                   }
                   f.paramList.addAll(fp.paramList); // Anadimos los demas parametros de otros tipos
                   RESULT = f; */
                   vl.tipo = t;
                   fp.varLists.push(vl);
                   RESULT = fp;
                   :};

TBAS ::= integer  {: Simbolo s = new Simbolo();
                     s.tipo = Simbolo.TipoSim.T_STRING;
                     s.valor = new StringBuilder("int");
                     RESULT = s; :}
       | real     {: Simbolo s = new Simbolo();
                     s.tipo = Simbolo.TipoSim.T_STRING;
                     s.valor = new StringBuilder("float");
                     RESULT = s; :} ;

// Zona de sentencias
SENT ::= ASIG:a punto_coma  {:
        a.valor.append(";");
        RESULT = a;
    :}
    | PROC_CALL:pc punto_coma {:
       pc.valor.append(";");
       RESULT = pc;
    :}
    | if_ EXPCOND:ec then BLQ:blq1 else_ BLQ:blq2 {:
        Sentencia e = new Sentencia();
        e.valor.append("if("+ec.valor+")"+blq1+"else"+blq2);
        RESULT = e;
     :}
     | while_ EXPCOND:ec do_ BLQ:blq  {:
        Sentencia e = new Sentencia();
        e.valor.append("while(").append(ec.valor).append(")\n").append(blq);
        RESULT = e;
     :}
     | repeat BLQ:blq until EXPCOND:ec punto_coma  {:
        Sentencia e = new Sentencia();
        e.valor.append("do\n").append(blq).append("\nuntil(").append(ec.valor).append(")");
        RESULT = e;
     :}
     | bucle_for identifier:id dos_p_igual EXP:exp1 INC:inc EXP:exp2 do_ BLQ:blq  {:
        /*Sentencia e = new Sentencia();
        e.valor.append("for("+id.valor+"="+exp1.valor+"; "+exp1.valor+inc.valor+exp2.valor+"; "+id.valor+"="+id.valor+inc.signo+")"+blq.valor);
        RESULT = e;*/
        Sentencia s = new Sentencia();
        s.valor.append("for (").append(id).append("=").append(exp1.valor).append("; ").append(id).append(inc.op);
        s.valor.append(exp2.valor).append(inc.valor).append("; ").append(id).append("=").append(id).append(inc.valor).append(")");
        s.valor.append("\n{").append(blq).append("}");
        RESULT = s;
     :};

INC ::= to {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder("<");
        s.signo = new StringBuilder("+1");
        RESULT = s;*/

        RESULT = new Incremento('<', "+1");
    :}
     | downto {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder(">");
        s.signo = new StringBuilder("-1");
        RESULT = s;*/

        RESULT = new Incremento('>', "-1");
    :};

ASIG ::= ID:id dos_p_igual EXP:exp {:
        StringBuilder valor = new StringBuilder(" ::= ").append(exp.valor);
        RESULT = new Sentencia(id.valor, valor, true);
    :};

ID ::= identifier:id {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder(id);
        RESULT = s;
    :};

EXP ::= EXP:e1 OP:op EXP:e2 {:
        /*Sentencia e = new Sentencia();

        e.valor.append(exp1.valor+" "+op.valor+" "+exp2.valor);
        RESULT = e;*/

        e1.valor.append(" ").append(op).append(" ").append(e2);
        RESULT = e1;
    :}
    | FACTOR:fact {:
        RESULT = fact;
    :} ;


OP ::= OPARIT:o {:
        RESULT = o;
    :};

OPARIT ::= op_mas{:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("+");
        RESULT = s;
    :}
    | op_men{:
       Simbolo s = new Simbolo();
       s.valor = new StringBuilder("-")
       ;RESULT = s;
    :}
    | op_mul {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("*");
        RESULT = s;
    :}
    | div {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("/");
        RESULT = s;
    :}
     | mod {:
        Simbolo s = new Simbolo();
        s.valor = new StringBuilder("%");
        RESULT = s; :} ;

FACTOR ::= SIMPVALUE:sv {:
            RESULT = new Sentencia(sv.valor);
        :}
        | ab_parentesis EXP:exp cr_parentesis {:
            Sentencia e = new Sentencia();
            e.valor.append("(").append(exp.valor).append(")");
            RESULT = e;
        :}
         | identifier:id SUBPPARAMLIST:spl {:
            Sentencia e = new Sentencia();
            e.valor.append(id).append(" ").append(spl.valor);
            RESULT = e;
      :} ;

SUBPPARAMLIST ::= ab_parentesis EXPLIST:el cr_parentesis{:
        Sentencia e = new Sentencia();
        e.valor.append(" ( ").append(el.valor).append(" ) ");
        RESULT = e;
    :}
    | /*lambda*/ {:
        RESULT = new Sentencia();
    :} ;

EXPLIST ::= EXP:exp {:
        RESULT = exp;
    :}
     | EXP:exp coma EXPLIST:expl {:
        exp.valor.append(", ").append(expl.valor);
        RESULT = exp;
     :};

PROC_CALL ::= identifier:id SUBPPARAMLIST:spl {:
        Sentencia s = new Sentencia();
        s.valor.append(id).append(" ").append(spl.valor);
        RESULT = s;
    :};

// Comprobacion de Sentenciaes condicionales (opcional)
EXPCOND ::= EXPCOND:exp1 OPLOG:op EXPCOND:exp2 {:
        exp1.valor.append(" ").append(op.valor).append(" ").append(exp2.valor);
        RESULT = exp1;
    :}
    | FACTORCOND:fc {:
        RESULT = fc;
    :} ;

OPLOG ::= or  {:    Simbolo s = new Simbolo();
                    s.valor = new StringBuilder("||");
                    RESULT = s; :}
        | and {:    Simbolo s = new Simbolo();
                    s.valor = new StringBuilder("&&");
                    RESULT = s; :} ;

FACTORCOND ::= EXP:e1 OPCOMP:op EXP:e2 {:
        e1.valor.append(op).append(e2.valor);
        RESULT = e1;
    :}
    | ab_parentesis EXP:exp cr_parentesis {:
        Sentencia s = new Sentencia();
        s.valor.append("(").append(exp.valor).append(")");
        RESULT = s;
    :}
    | not FACTORCOND:fc {:
        Sentencia s = new Sentencia();
        s.valor.append("!").append(fc.valor);
        RESULT = s;
     :};

OPCOMP ::= lt  {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder("<");
        RESULT = s;*/
        RESULT = new StringBuilder("<");
    :}
    | gt  {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder(">");
        RESULT = s;*/
        RESULT = new StringBuilder(">");
    :}
    | let {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder("<=");
        RESULT = s;*/
        RESULT = new StringBuilder("<=");
    :}
    | bet {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder(">=");
        RESULT = s;*/
        RESULT = new StringBuilder(">=");
    :}
    | igual {:
        /*Simbolo s = new Simbolo();
        s.valor = new StringBuilder("==");
        RESULT = s;*/
        RESULT = new StringBuilder("==");
    :};
